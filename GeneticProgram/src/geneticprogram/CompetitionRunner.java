package geneticprogram;

import java.io.FileWriter;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Random;
import java.util.concurrent.CountDownLatch;

public class CompetitionRunner {

          private static CompetitionRunner singleton = null;

          private int run;

          private final Random rng;//

          /* These are parameters were used for the competition, so if they are changed then the results may not be comparable to those of the competition */
          private final int number_of_runs = 31;
          private static final int domains = 6;
          private static final int instances = 5;

          //private static long instanceseed;
          private final long[][][] instance_seeds;

          /*
		 * These instances are generated by CompetitionInstanceSelector.java
		 * Ten instances are included for each problem domain, but these are the instances selected for use in the competition.
		 * The last two instances of the first four domains were hidden instances.
           */
          private static final int[][] instances_to_use = {
                    {3, 5, 4, 10, 11}, //sat
                    {7, 1, 9, 10, 11}, //bp
                    {5, 9, 8, 10, 11},//ps
                    {1, 8, 3, 10, 11},//fs
                    {0, 8, 2, 7, 6},//tsp
                    {6, 2, 5, 1, 9}//vrp
          };
          private static final String[] problem_domains = {
                    "sat",
                    "bp",
                    "ps",
                    "fs",
                    "tsp",
                    "vrp"
          };

          /**
           * @param run_instance
           */
          private CompetitionRunner() {
                    this.rng = new Random(123456789);
                    this.instance_seeds = new long[domains][instances][number_of_runs];
                    for (int x = 0; x < domains; x++) {
                              for (int y = 0; y < instances; y++) {
                                        for (int r = 0; r < number_of_runs; r++) {
                                                  instance_seeds[x][y][r] = rng.nextLong();
                                        }
                              }
                    }
          }

          public CompetitionRunner getInstance(int run) {
                    if (singleton == null) {
                              singleton = new CompetitionRunner();
                    }
                    singleton.run = run;
                    return singleton;
          }

          public void run(Program prog) throws Exception {
                    for (int d = 0; d < domains; d++) {
                              for (int i = 0; i < instances; i++) {
                                        //
                                        run(prog, d, i);
                              }
                    }
          }

          private void run(Program prog, int problem, int instance) throws Exception {
                    try {
                              FileWriter fwriter = new FileWriter("run_" + (run + 1) + "/results/" + problem + "-" + instance + ".txt");
                              PrintWriter printer = new PrintWriter(fwriter);
                              System.out.println("PROBLEM DOMAIN " + problem_domains[problem]);
                              printer.println("PROBLEM DOMAIN " + problem_domains[problem]);
                              System.out.println("  instance " + instances_to_use[problem][instance] + " ");
                              printer.println("  instance " + instances_to_use[problem][instance] + " ");
                              FileWriter f = new FileWriter("run_" + (run + 1) + "/results/" + problem_domains[problem] + "/instance" + instance + ".txt");
                              PrintWriter buffprint = new PrintWriter(f);

                              CountDownLatch latch = new CountDownLatch(number_of_runs);
                              ArrayList<RunnerThread> threads = FlyWeight.getInstance().getRunnerThreads();
                              for (int r = 0; r < number_of_runs; r++) {
                                        long instance_seed = instance_seeds[problem][instance][run];

                                        System.out.println("    RUN " + r + " " + instance_seed);
                                        printer.println("    RUN " + r);

                                        RunnerThread thread = FlyWeight.getInstance().getRunnerThread();
                                        thread.reset(latch, prog, instance_seed, problem, instances_to_use[problem][instance]);

                                        System.out.print("      HYPER HEURISTIC " + thread.toString());

                                        thread.run();
                                        threads.add(thread);

                              }
                              latch.await();
                              for (int r = 0; r < number_of_runs; r++) {
                                        RunnerThread thread = threads.remove(0);

                                        System.out.println("\t" + thread.getBestSolutionValue() + "\t" + (thread.getElapsedTime() / 1000.0) + "\t" + (thread.getRunTime()) / 1000.0 + "\t" + thread.getTotalHeuristicCalls());
                                        printer.println("\t" + thread.getBestSolutionValue() + "\t" + (thread.getElapsedTime() / 1000.0) + "\t" + (thread.getRunTime()) / 1000.0 + "\t" + thread.getTotalHeuristicCalls());
                                        buffprint.print(thread.getBestSolutionValue() + " ");

                                        FileWriter f1 = new FileWriter("run_" + (run + 1) + "/results/" + problem_domains[problem] + "/time" + instance + ".txt", true);
                                        PrintWriter buffprint1 = new PrintWriter(f1);
                                        double[] u = thread.getFitnessTrace();
                                        for (double y : u) {
                                                  buffprint1.print(y + " ");
                                        }
                                        buffprint1.println();
                                        buffprint1.close();
                                        f1.close();
                                        FlyWeight.getInstance().addRunnerThread(thread);
                              }
                              FlyWeight.getInstance().addRunnerThreads(threads);
                              printer.close();
                              fwriter.close();
                              buffprint.close();
                              f.close();
                    } catch (Exception e) {
                              System.err.println(e.getMessage());
                              System.exit(0);
                    }
          }

}
